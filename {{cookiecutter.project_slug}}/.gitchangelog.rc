# -*- coding: utf-8; mode: python -*-
##
## Format
##
##   ACTION: [AUDIENCE:] COMMIT_MSG [!TAG ...]
##
## Description
##
##   ACTION is one of 'chg', 'fix', 'new'
##
##       Is WHAT the change is about.
##
##       'chg' is for refactor, small improvement, cosmetic changes...
##       'fix' is for bug fixes
##       'new' is for new features, big improvement
##
##   AUDIENCE is optional and one of 'dev', 'usr', 'pkg', 'test', 'doc'
##
##       Is WHO is concerned by the change.
##
##       'dev'  is for developpers (API changes, refactors...)
##       'usr'  is for final users (UI changes)
##       'pkg'  is for packagers   (packaging changes)
##       'test' is for testers     (test only related changes)
##       'doc'  is for doc guys    (doc only changes)
##
##   COMMIT_MSG is ... well ... the commit message itself.
##
##   TAGs are additionnal adjective as 'refactor' 'minor' 'cosmetic'
##
##       They are preceded with a '!' or a '@' (prefer the former, as the
##       latter is wrongly interpreted in github.) Commonly used tags are:
##
##       'refactor' is obviously for refactoring code only
##       'minor' is for a very meaningless change (a typo, adding a comment)
##       'cosmetic' is for cosmetic driven change (re-indentation, 80-col...)
##       'wip' is for partial functionality but complete subfunctionality.

## Any commit having its full commit message matching any regexp listed here
## will be ignored and won't be reported in the changelog.
ignore_regexps = [
    r'@minor', r'!minor',
    r'@cosmetic', r'!cosmetic',
    r'@refactor', r'!refactor',
    r'@wip', r'!wip',
    r'^([cC]hg|[fF]ix|[nN]ew)\s*:\s*[p|P]kg:',
    r'^([cC]hg|[fF]ix|[nN]ew)\s*:\s*[d|D]ev:',
    r'^(.{3,3}\s*:)?\s*[fF]irst commit.?\s*$',
    r'^$',  ## ignore commits with empty messages
]

## Commit messages will be classified in sections thanks to this. Section
## titles are the label, and a commit is classified under this section if any
## of the regexps associated is matching.
section_regexps = [
    ('Features', [
        r'^(?=.*\b[fF]eature\/)(?=.*\b[pP]ull request #[0-9]+\b).*$',
     ]),
    ('Bugfixes', [
        r'^(?=.*\b[bB]ugfix\/)(?=.*\b[pP]ull request #[0-9]+\b).*$',
     ]),
    ('Other', [
        r'[pP]ull request #[0-9]+',
     ])
]

## This callable will be given the original body and result will
## be used in the changelog.
body_process = ReSub(r'((^|\n)[A-Z]\w+(-\w+)*: .*(\n\s+.*)*)+$', r'') | strip

## This callable will be given the original subject and result will
## be used in the changelog.
subject_process = (strip | ucfirst | final_dot)

## Tags that will be used for the changelog must match this regexp.
tag_filter_regexp = r'^[0-9]+\.[0-9]+(\.[0-9]+)?$'

## This label will be used as the changelog Title of the last set of changes
## between last valid tag and HEAD if any.
unreleased_version_label = "_Next_Version_Number_"

## This will change the output format of the generated changelog file
output_engine = mustache("markdown")

## This option tells git-log whether to include merge commits in the log.
## The default is to include them.
include_merge = True

## Sets what ``gitchangelog`` should do with the output generated by
## the output engine. ``publish`` is a callable taking one argument
## that is an interator on lines from the output engine.
publish = FileInsertAtFirstRegexMatch(
    "CHANGELOG.md",
    r"(?P<rev>#+\s[0-9]+\.[0-9]+(\.[0-9]+)?)\s*\n",
    idx=lambda m: m.start(1)
)

## callable will be called to resolve as strings and allow dynamical
## computation of these. The result will be used as revisions for
## gitchangelog (as if directly stated on the command line). This allows
## to filter exaclty which commits will be read by gitchangelog.
#revs = []
revs = [
   Caret(
       FileFirstRegexMatch(
           "CHANGELOG.md",
           r"#+\sv?(?P<rev>[0-9]+\.[0-9]+(\.[0-9]+)?)\s*\n")),
   "HEAD"
]
